/**
 * Copyright (c) 2022, WSO2 Inc. (http://www.wso2.com) All Rights Reserved.
 *
 * WSO2 Inc. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { AsgardeoAuthException, AuthenticationHelper } from "@asgardeo/auth-spa";
import { flatten } from "flatten-anything";
import { GRANT_TYPE, REQUESTED_TOKEN_TYPE, SUBJECT_TOKEN_TYPE } from "../constants/exchange";
import { StsStore } from "../constants/stsStore";
export class TokenExchangeAuthenticationHelper extends AuthenticationHelper {
    constructor(authClient, spaHelper) {
        super(authClient, spaHelper);
    }
    exchangeAccessToken() {
        const _super = Object.create(null, {
            getAccessToken: { get: () => super.getAccessToken }
        });
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const accessToken = yield _super.getAccessToken.call(this);
            const config = (yield this._dataLayer.getConfigData());
            if (!accessToken) {
                throw new AsgardeoAuthException("TOKEN_EXCHANGE-AUTH_HELPER-RAT2-NF01", "Invalid access token.", "Failed retrieving access token.");
            }
            const exchangeGrantData = {
                grant_type: GRANT_TYPE,
                requested_token_type: REQUESTED_TOKEN_TYPE,
                subject_token: accessToken,
                subject_token_type: SUBJECT_TOKEN_TYPE
            };
            const flattenedData = flatten(Object.assign({}, config === null || config === void 0 ? void 0 : config.stsConfig), 1);
            for (let key in flattenedData) {
                let value = flattenedData[key];
                if (key === "scope" && Array.isArray(value)) {
                    value = value.join(" ");
                }
                else if (key === "credentials.client_id") {
                    key = "client_id";
                }
                else if (key === "credentials.client_secret") {
                    key = "client_secret";
                }
                exchangeGrantData[key] = value;
            }
            const formBody = [];
            for (const property in exchangeGrantData) {
                const encodedKey = encodeURIComponent(property);
                const encodedValue = encodeURIComponent(exchangeGrantData[property]);
                formBody.push(`${encodedKey}=${encodedValue}`);
            }
            const requestOptions = {
                body: formBody.join("&"),
                credentials: "include",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    authorization: `Bearer ${accessToken}`
                },
                method: "POST",
                mode: "cors"
            };
            try {
                const res = yield fetch((_a = config === null || config === void 0 ? void 0 : config.stsTokenEndpoint) !== null && _a !== void 0 ? _a : "", requestOptions);
                if (!res.ok) {
                    throw new AsgardeoAuthException("TOKEN_EXCHANGE-AUTH_HELPER-EAT1-NE01", "Invalid exchanging token response", "Token exchange grant has been failed");
                }
                const responseBody = yield res.json();
                if (responseBody === null || responseBody === void 0 ? void 0 : responseBody.access_token) {
                    yield this._dataLayer.setCustomData(StsStore.SessionData, responseBody);
                }
            }
            catch (error) {
                throw new AsgardeoAuthException("TOKEN_EXCHANGE-AUTH_HELPER-EAT1-NE02", "Error in exchanging token", "Token exchange grant has been failed");
            }
        });
    }
    refreshStsAccessToken() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        return __awaiter(this, void 0, void 0, function* () {
            const config = (yield this._dataLayer.getConfigData());
            const stsSessionData = yield this._dataLayer.getCustomData(StsStore.SessionData);
            if (!(stsSessionData === null || stsSessionData === void 0 ? void 0 : stsSessionData.refresh_token)) {
                throw new AsgardeoAuthException("TOKEN_EXCHANGE-AUTH_HELPER-RSAT1-NF01", "Refresh token not found", "STS is not configured to return refresh token");
            }
            else if (!((_b = (_a = config === null || config === void 0 ? void 0 : config.stsConfig) === null || _a === void 0 ? void 0 : _a.credentials) === null || _b === void 0 ? void 0 : _b.client_id) ||
                !((_d = (_c = config === null || config === void 0 ? void 0 : config.stsConfig) === null || _c === void 0 ? void 0 : _c.credentials) === null || _d === void 0 ? void 0 : _d.client_secret)) {
                throw new AsgardeoAuthException("TOKEN_EXCHANGE-AUTH_HELPER-RSAT2-NF02", "Client credentials not found", "Client credentials are not configured");
            }
            const encodedAuthHeader = btoa(`${(_f = (_e = config === null || config === void 0 ? void 0 : config.stsConfig) === null || _e === void 0 ? void 0 : _e.credentials) === null || _f === void 0 ? void 0 : _f.client_id}:${(_h = (_g = config === null || config === void 0 ? void 0 : config.stsConfig) === null || _g === void 0 ? void 0 : _g.credentials) === null || _h === void 0 ? void 0 : _h.client_secret}`);
            const requestOptions = {
                body: `grant_type=refresh_token&refresh_token=${stsSessionData.refresh_token}`,
                credentials: "include",
                headers: {
                    "Content-Type": "application/x-www-form-urlencoded",
                    authorization: `Basic ${encodedAuthHeader.replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "")}`
                },
                method: "POST",
                mode: "cors"
            };
            try {
                const response = yield fetch((_j = config === null || config === void 0 ? void 0 : config.stsTokenEndpoint) !== null && _j !== void 0 ? _j : "", requestOptions);
                if (!response.ok) {
                    throw new AsgardeoAuthException("TOKEN_EXCHANGE-AUTH_HELPER-RSAT3-NE01", "Invalid refresh token response", "STS token refreshing has been failed");
                }
                const responseBody = yield response.json();
                if (responseBody === null || responseBody === void 0 ? void 0 : responseBody.access_token) {
                    yield this._dataLayer.setCustomData(StsStore.SessionData, responseBody);
                }
            }
            catch (error) {
                throw new AsgardeoAuthException("TOKEN_EXCHANGE-AUTH_HELPER-EAT1-NE02", "Error in refreshing token", "STS token refreshing has been failed");
            }
        });
    }
    requestAccessToken(authorizationCode, sessionState, checkSession, pkce, state) {
        const _super = Object.create(null, {
            requestAccessToken: { get: () => super.requestAccessToken }
        });
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const userInfo = yield _super.requestAccessToken.call(this, authorizationCode, sessionState, checkSession, pkce, state);
                yield this.exchangeAccessToken();
                return userInfo;
            }
            catch (error) {
                return Promise.reject(new AsgardeoAuthException("TOKEN_EXCHANGE-AUTH_HELPER-RAT3-NF01", (_a = error === null || error === void 0 ? void 0 : error.name) !== null && _a !== void 0 ? _a : "Failed requesting access token.", (_b = error === null || error === void 0 ? void 0 : error.message) !== null && _b !== void 0 ? _b : "Failed retrieving user info."));
            }
        });
    }
    getAccessToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const stsSessionData = yield this._dataLayer.getCustomData(StsStore.SessionData);
            return stsSessionData === null || stsSessionData === void 0 ? void 0 : stsSessionData.access_token;
        });
    }
    refreshAccessToken(enableRetrievingSignOutURLFromSession) {
        const _super = Object.create(null, {
            refreshAccessToken: { get: () => super.refreshAccessToken }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let userInfo = {};
            try {
                this.refreshStsAccessToken();
            }
            catch (error) {
                userInfo = yield _super.refreshAccessToken.call(this, enableRetrievingSignOutURLFromSession);
                yield this.exchangeAccessToken();
            }
            // Automatically refresh the sts access token
            this.refreshAccessTokenAutomatically();
            return userInfo;
        });
    }
    refreshAccessTokenAutomatically() {
        return __awaiter(this, void 0, void 0, function* () {
            const stsSessionData = yield this._dataLayer.getCustomData(StsStore.SessionData);
            if (stsSessionData === null || stsSessionData === void 0 ? void 0 : stsSessionData.expires_in) {
                // Refresh 10 seconds before the expiry time
                const expiryTime = parseInt(stsSessionData.expires_in);
                const time = expiryTime <= 10 ? expiryTime : expiryTime - 10;
                setTimeout(() => __awaiter(this, void 0, void 0, function* () {
                    yield this.refreshAccessToken();
                }), time * 1000);
            }
        });
    }
    getDecodedIDToken() {
        const _super = Object.create(null, {
            getCryptoHelper: { get: () => super.getCryptoHelper }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // TODO Uncomment this once choreo STS enable id token in the response. 
            // Temporarily referring to IDP session data
            // const stsSessionData =
            //     await this._dataLayer.getCustomData<StsExchangeResponse>(
            //         StsStore.SessionData
            //     );
            const stsSessionData = yield this._dataLayer.getSessionData();
            const idToken = stsSessionData === null || stsSessionData === void 0 ? void 0 : stsSessionData.id_token;
            if (!idToken) {
                return Promise.reject(new AsgardeoAuthException("TOKEN_EXCHANGE-AUTH_HELPER-GDIT-NF01", "Failed requesting access token.", "Failed retrieving user info."));
            }
            const cryptoHelper = yield _super.getCryptoHelper.call(this);
            const payload = cryptoHelper.decodeIDToken(idToken);
            return payload;
        });
    }
}
//# sourceMappingURL=authentication-helper.js.map